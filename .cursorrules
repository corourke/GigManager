# Cursor Rules for GigManager project

## Application Context
**Gig Manager** is a production and event management platform used by:

- Production companies managing events and performances
- Sound and lighting companies tracking equipment and staff
- Event producers coordinating venues, acts, and logistics

## Database Changes
- All database schema changes (DDL statements) that build on `supabase/schema.sql` must be created as migration files in `supabase/migrations/`
- Migration files should be named with a timestamp prefix: `YYYYMMDDHHMM_description.sql`
- After creating a migration file, also update `supabase/schema.sql` to keep it in sync
- Provide instructions for applying migrations in Supabase SQL Editor when needed


## UI guidelines

* Don't create separate components for Add and Update screens, use one form component with logic to correctly handle both Create and Update operations. 
* Only use absolute positioning when necessary. Opt for responsive and well structured layouts that use flexbox and grid by default.
* Refactor code as you go to keep code clean.
* Keep file sizes small and put helper functions and components in their own files.

### Form Building Patterns

* **Use `useFormWithChanges` hook for change detection** - All create/edit forms must use the `useFormWithChanges` hook from `src/utils/hooks/useFormWithChanges.ts` to track changes and enable/disable submit buttons appropriately.

* **Include nested data in change detection** - When forms have nested data (e.g., staff slots, kit assets, participants) stored in separate state (not in react-hook-form), include them in change detection:
  - Use `watch()` from react-hook-form to get form values: `const formValues = watch()`
  - Use `useMemo` to create a `currentData` object that includes both form values and nested data: `const currentData = useMemo(() => ({ ...formValues, nestedData: nestedData }), [formValues, nestedData])`
  - Add nested data fields to `initialData` in the hook configuration (e.g., `staffSlots: []`)
  - Pass `currentData` to the hook's `currentData` option
  - Include nested data in `loadInitialData()` when loading existing records (e.g., `staffSlots: loadedSlots || []`)
  - Include nested data in `markAsSaved()` after successful save (e.g., `staffSlots: staffSlots`)
  - Use `useEffect` with a ref pattern to trigger `updateChangedFields()` when nested data changes (since form watch doesn't cover nested state):
    - Store `updateChangedFields` in a ref to avoid dependency issues: `const updateChangedFieldsRef = useRef(changeDetection.updateChangedFields); updateChangedFieldsRef.current = changeDetection.updateChangedFields;`
    - Use a ref to track previous nested data values: `const prevNestedDataRef = useRef<NestedDataType[]>([]);`
    - In the effect, compare current vs previous values (e.g., using JSON.stringify for deep comparison)
    - Only call `updateChangedFieldsRef.current()` when nested data actually changed
    - **Critical**: Do NOT include `changeDetection` in the dependency array - it's recreated on every render and causes infinite loops. Only include the nested data state and `isEditMode`.

* **Button enablement** - Submit buttons should be disabled when `isEditMode && !changeDetection.hasChanges`. This ensures buttons only enable when actual changes are detected (including nested data changes).

* **Partial updates in edit mode** - In edit mode, only send changed fields to the API:
  - Use `changeDetection.getChangedFields()` to get only modified fields
  - Only include fields in the update payload if they appear in `changedFields`
  - Always send nested data (participants, staff slots, etc.) if they're complex and always saved together
  - For arrays like tags, ensure empty arrays are sent when removing all items: `data.tags || []`

* **Form state management** - Prefer react-hook-form for form fields, but use local state for complex nested data structures. When mixing both:
  - Form fields are automatically tracked via the hook's form watch
  - Nested state requires manual inclusion via `currentData` and `useEffect` triggers

* **Consistency across forms** - All create/edit forms should follow the same pattern:
  - Use `useFormWithChanges` hook
  - Track both form fields and nested data
  - Enable/disable buttons based on `hasChanges`
  - Only send changed fields in edit mode
  - Call `markAsSaved()` after successful save with all current values (including nested data)

### Tables and Lists

* **Use auto table layout** - Never use `table-layout: fixed` on tables. Use the default auto layout to allow columns to adapt to content naturally.
* **Use min-width instead of fixed widths** - Set `min-width` values on table columns to prevent collapsing, but allow columns to expand beyond the minimum to accommodate content. Avoid fixed `width` values that force rigid column sizes.
* **Allow text wrapping** - Override default `whitespace-nowrap` behavior by adding `whitespace-normal` to table headers and cells. This prevents column overlap by allowing text to wrap when space is constrained.
* **Prevent column collapse** - Set appropriate `min-width` values on columns that should maintain a minimum size (e.g., Title column should have `min-w-[200px]` to prevent collapsing on narrow screens).
* **Use overflow-x-auto wrapper** - Wrap tables in a container with `overflow-x-auto` to enable horizontal scrolling when content exceeds viewport width, rather than forcing columns to overlap.
* **Let content determine width** - Columns should size based on their content first, then respect minimum widths, allowing the table to expand naturally while maintaining readability.

## Coding Principles

### 1. Type Safety First

- **Prefer TypeScript with strict mode enabled**

### 2. Organization Context

- **Every API route must verify user membership** in the organization
- **Every database query must filter by `organization_id`** (enforced by RLS)
- **Use middleware or helper functions** to extract and validate organization context
- **Default to rejecting access** if organization membership cannot be verified
- **Never trust client-provided organization IDs** without server-side verification

### 3. Error Handling

- **Always use standardized error responses** consistent across the application
- Always catch and handle errors gracefully
- Log errors server-side for debugging
- Return user-friendly error messages (don't expose internal details)
- Use specific error codes for different error types
- Include validation details in `details` field for form validation errors

### 4. Database Access

- **Always include `organization_id` in WHERE clauses** for tenant-scoped queries
- **Use transactions for multi-step operations** that must be atomic
- Ensure referential integrity
- Use UUIDs for all primary keys
- Timestamps use server-side defaults

### 5. Security

- **Never trust client input** - always validate on the server
- **Verify authentication** before any protected operation
- **Verify authorization** (organization membership, role) before sensitive operations
- **Sanitize user input** before displaying (React handles this by default, but be careful with `dangerouslySetInnerHTML`)
- **Use HTTPS in production**
- **Never expose sensitive data** in error messages or logs

### 6. Performance

- **Use database indexes** for frequently queried fields
- **Implement pagination** for large result sets
- **Use `select` to limit fields** returned from database when possible
- **Cache frequently accessed data** when appropriate
- **Use React Server Components by default** (App Router)

### 7. Maintainability

- **Write self-documenting code** with clear variable and function names
- **Extract reusable logic** into utility functions
- **Keep functions focused** on a single responsibility
- **Add comments for complex business logic**
- Only use absolute positioning when necessary. Opt for responsive and well structured layouts that use flexbox and grid by default
- Refactor code as you go to keep code clean
- **Keep components small and focused** -- Keep file sizes small and put helper functions and components in their own files.